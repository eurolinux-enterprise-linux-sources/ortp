diff --git a/include/ortp/str_utils.h b/include/ortp/str_utils.h
index ae073dd..6c12065 100644
--- a/include/ortp/str_utils.h
+++ b/include/ortp/str_utils.h
@@ -73,11 +73,11 @@ void flushq(queue_t *q, int how);
 void mblk_init(mblk_t *mp);
 	
 /* allocates a mblk_t, that points to a datab_t, that points to a buffer of size size. */
-mblk_t *allocb(int size, int unused);
+mblk_t *allocb(size_t size, int unused);
 #define BPRI_MED 0
 
 /* allocates a mblk_t, that points to a datab_t, that points to buf; buf will be freed using freefn */
-mblk_t *esballoc(uint8_t *buf, int size, int pri, void (*freefn)(void*) );
+mblk_t *esballoc(uint8_t *buf, size_t size, int pri, void (*freefn)(void*) );
 
 /* frees a mblk_t, and if the datab ref_count is 0, frees it and the buffer too */
 void freeb(mblk_t *m);
@@ -93,10 +93,10 @@ mblk_t *dupb(mblk_t *m);
 mblk_t	*dupmsg(mblk_t* m);
 
 /* returns the size of data of a message */
-int msgdsize(const mblk_t *mp);
+size_t msgdsize(const mblk_t *mp);
 
 /* concatenates all fragment of a complex message*/
-void msgpullup(mblk_t *mp,int len);
+void msgpullup(mblk_t *mp,size_t len);
 
 /* duplicates a single message, but with buffer included */
 mblk_t *copyb(mblk_t *mp);
@@ -104,8 +104,8 @@ mblk_t *copyb(mblk_t *mp);
 /* duplicates a complex message with buffer included */
 mblk_t *copymsg(mblk_t *mp);
 
-mblk_t * appendb(mblk_t *mp, const char *data, int size, bool_t pad);
-void msgappend(mblk_t *mp, const char *data, int size, bool_t pad);
+mblk_t * appendb(mblk_t *mp, const char *data, size_t size, bool_t pad);
+void msgappend(mblk_t *mp, const char *data, size_t size, bool_t pad);
 
 mblk_t *concatb(mblk_t *mp, mblk_t *newm);
 
@@ -121,7 +121,7 @@ typedef struct _msgb_allocator{
 }msgb_allocator_t;
 
 void msgb_allocator_init(msgb_allocator_t *pa);
-mblk_t *msgb_allocator_alloc(msgb_allocator_t *pa, int size);
+mblk_t *msgb_allocator_alloc(msgb_allocator_t *pa, size_t size);
 void msgb_allocator_uninit(msgb_allocator_t *pa);
 
 #ifdef __cplusplus
diff --git a/src/str_utils.c b/src/str_utils.c
index a38620b..81afcda 100644
--- a/src/str_utils.c
+++ b/src/str_utils.c
@@ -37,9 +37,9 @@ void mblk_init(mblk_t *mp)
 	mp->reserved2=0;
 }
 
-dblk_t *datab_alloc(int size){
+dblk_t *datab_alloc(size_t size){
 	dblk_t *db;
-	int total_size=sizeof(dblk_t)+size;
+	size_t total_size=sizeof(dblk_t)+size;
 	db=(dblk_t *) ortp_malloc(total_size);
 	db->db_base=(uint8_t*)db+sizeof(dblk_t);
 	db->db_lim=db->db_base+size;
@@ -62,48 +62,48 @@ static inline void datab_unref(dblk_t *d){
 }
 
 
-mblk_t *allocb(int size, int pri)
+mblk_t *allocb(size_t size, int pri)
 {
 	mblk_t *mp;
 	dblk_t *datab;
-	
+
 	mp=(mblk_t *) ortp_malloc(sizeof(mblk_t));
 	mblk_init(mp);
 	datab=datab_alloc(size);
-	
+
 	mp->b_datap=datab;
 	mp->b_rptr=mp->b_wptr=datab->db_base;
 	mp->b_next=mp->b_prev=mp->b_cont=NULL;
 	return mp;
 }
 
-mblk_t *esballoc(uint8_t *buf, int size, int pri, void (*freefn)(void*) )
+mblk_t *esballoc(uint8_t *buf, size_t size, int pri, void (*freefn)(void*) )
 {
 	mblk_t *mp;
 	dblk_t *datab;
-	
+
 	mp=(mblk_t *) ortp_malloc(sizeof(mblk_t));
 	mblk_init(mp);
 	datab=(dblk_t *) ortp_malloc(sizeof(dblk_t));
-	
+
 
 	datab->db_base=buf;
 	datab->db_lim=buf+size;
 	datab->db_ref=1;
 	datab->db_freefn=freefn;
-	
+
 	mp->b_datap=datab;
 	mp->b_rptr=mp->b_wptr=buf;
 	mp->b_next=mp->b_prev=mp->b_cont=NULL;
 	return mp;
 }
 
-	
+
 void freeb(mblk_t *mp)
 {
 	return_if_fail(mp->b_datap!=NULL);
 	return_if_fail(mp->b_datap->db_base!=NULL);
-	
+
 	datab_unref(mp->b_datap);
 	ortp_free(mp);
 }
@@ -125,7 +125,7 @@ mblk_t *dupb(mblk_t *mp)
 	mblk_t *newm;
 	return_val_if_fail(mp->b_datap!=NULL,NULL);
 	return_val_if_fail(mp->b_datap->db_base!=NULL,NULL);
-	
+
 	datab_ref(mp->b_datap);
 	newm=(mblk_t *) ortp_malloc(sizeof(mblk_t));
 	mblk_init(newm);
@@ -192,7 +192,7 @@ void insq(queue_t *q,mblk_t *emp, mblk_t *mp)
 	emp->b_prev->b_next=mp;
 	mp->b_prev=emp->b_prev;
 	emp->b_prev=mp;
-	mp->b_next=emp;	
+	mp->b_next=emp;
 }
 
 void remq(queue_t *q, mblk_t *mp){
@@ -207,24 +207,24 @@ void remq(queue_t *q, mblk_t *mp){
 void flushq(queue_t *q, int how)
 {
 	mblk_t *mp;
-	
+
 	while ((mp=getq(q))!=NULL)
 	{
 		freemsg(mp);
 	}
 }
 
-int msgdsize(const mblk_t *mp)
+size_t msgdsize(const mblk_t *mp)
 {
-	int msgsize=0;
+	size_t msgsize=0;
 	while(mp!=NULL){
-		msgsize+=(int) (mp->b_wptr-mp->b_rptr);
+		msgsize+=(size_t) (mp->b_wptr-mp->b_rptr);
 		mp=mp->b_cont;
 	}
 	return msgsize;
 }
 
-void msgpullup(mblk_t *mp,int len)
+void msgpullup(mblk_t *mp,size_t len)
 {
 	mblk_t *firstm=mp;
 	dblk_t *db;
@@ -279,15 +279,15 @@ mblk_t *copymsg(mblk_t *mp)
 	return newm;
 }
 
-mblk_t * appendb(mblk_t *mp, const char *data, int size, bool_t pad){
-	int padcnt=0;
-	int i;
+mblk_t * appendb(mblk_t *mp, const char *data, size_t size, bool_t pad){
+	size_t padcnt=0;
+	size_t i;
 	if (pad){
-		padcnt= (int)(4L-( (long)(((long)mp->b_wptr)+size) % 4L)) % 4L;
+		padcnt= (size_t)(4L-( (long)(((long)mp->b_wptr)+size) % 4L)) % 4L;
 	}
 	if ((mp->b_wptr + size +padcnt) > mp->b_datap->db_lim){
 		/* buffer is not large enough: append a new block (with the same size ?)*/
-		int plen=(int)((char*)mp->b_datap->db_lim - (char*) mp->b_datap->db_base);
+		size_t plen=(size_t)((char*)mp->b_datap->db_lim - (char*) mp->b_datap->db_base);
 		mp->b_cont=allocb(MAX(plen,size),0);
 		mp=mp->b_cont;
 	}
@@ -300,7 +300,7 @@ mblk_t * appendb(mblk_t *mp, const char *data, int size, bool_t pad){
 	return mp;
 }
 
-void msgappend(mblk_t *mp, const char *data, int size, bool_t pad){
+void msgappend(mblk_t *mp, const char *data, size_t size, bool_t pad){
 	while(mp->b_cont!=NULL) mp=mp->b_cont;
 	appendb(mp,data,size,pad);
 }
@@ -316,7 +316,7 @@ void msgb_allocator_init(msgb_allocator_t *a){
 	qinit(&a->q);
 }
 
-mblk_t *msgb_allocator_alloc(msgb_allocator_t *a, int size){
+mblk_t *msgb_allocator_alloc(msgb_allocator_t *a, size_t size){
 	queue_t *q=&a->q;
 	mblk_t *m,*found=NULL;
 
